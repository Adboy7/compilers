Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    bool
    class
    dot
    eof
    extends
    int32
    lbrace
    string
    unit

Grammar

Rule 0     S' -> formals
Rule 1     formals -> formal
Rule 2     formals -> formals comma formal
Rule 3     formals -> empty
Rule 4     formal -> object_identifier colon type_identifier
Rule 5     block -> rbrace expression semicolon expression
Rule 6     expression -> if expression then expression
Rule 7     expression -> if expression then expression else expression
Rule 8     expression -> while expression do expression
Rule 9     expression -> let object_identifier colon type_identifier in expression
Rule 10    expression -> let object_identifier colon type_identifier assign expression in expression
Rule 11    expression -> object_identifier assign expression
Rule 12    expression -> not expression
Rule 13    expression -> expression and expression
Rule 14    expression -> expression equal expression
Rule 15    expression -> expression lower_equal expression
Rule 16    expression -> expression lower expression
Rule 17    expression -> expression plus expression
Rule 18    expression -> expression minus expression
Rule 19    expression -> expression times expression
Rule 20    expression -> expression div expression
Rule 21    expression -> expression pow expression
Rule 22    expression -> minus expression
Rule 23    expression -> isnull expression
Rule 24    expression -> object_identifier lpar args rpar
Rule 25    expression -> new type_identifier
Rule 26    expression -> object_identifier
Rule 27    expression -> literal
Rule 28    expression -> lpar rpar
Rule 29    expression -> lpar expression rpar
Rule 30    expression -> block
Rule 31    args -> expression
Rule 32    args -> args comma expression
Rule 33    args -> empty
Rule 34    literal -> integer_literal
Rule 35    literal -> string_literal
Rule 36    literal -> boolean_literal
Rule 37    boolean_literal -> true
Rule 38    boolean_literal -> false
Rule 39    empty -> <empty>

Terminals, with rules where they appear

and                  : 13
assign               : 10 11
bool                 : 
class                : 
colon                : 4 9 10
comma                : 2 32
div                  : 20
do                   : 8
dot                  : 
else                 : 7
eof                  : 
equal                : 14
error                : 
extends              : 
false                : 38
if                   : 6 7
in                   : 9 10
int32                : 
integer_literal      : 34
isnull               : 23
lbrace               : 
let                  : 9 10
lower                : 16
lower_equal          : 15
lpar                 : 24 28 29
minus                : 18 22
new                  : 25
not                  : 12
object_identifier    : 4 9 10 11 24 26
plus                 : 17
pow                  : 21
rbrace               : 5
rpar                 : 24 28 29
semicolon            : 5
string               : 
string_literal       : 35
then                 : 6 7
times                : 19
true                 : 37
type_identifier      : 4 9 10 25
unit                 : 
while                : 8

Nonterminals, with rules where they appear

args                 : 24 32
block                : 30
boolean_literal      : 36
empty                : 3 33
expression           : 5 5 6 6 7 7 7 8 8 9 10 10 11 12 13 13 14 14 15 15 16 16 17 17 18 18 19 19 20 20 21 21 22 23 29 31 32
formal               : 1 2
formals              : 2 0
literal              : 27

Parsing method: LALR

state 0

    (0) S' -> . formals
    (1) formals -> . formal
    (2) formals -> . formals comma formal
    (3) formals -> . empty
    (4) formal -> . object_identifier colon type_identifier
    (39) empty -> .

    object_identifier shift and go to state 4
    comma           reduce using rule 39 (empty -> .)
    $end            reduce using rule 39 (empty -> .)

    formals                        shift and go to state 1
    formal                         shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> formals .
    (2) formals -> formals . comma formal

    comma           shift and go to state 5


state 2

    (1) formals -> formal .

    comma           reduce using rule 1 (formals -> formal .)
    $end            reduce using rule 1 (formals -> formal .)


state 3

    (3) formals -> empty .

    comma           reduce using rule 3 (formals -> empty .)
    $end            reduce using rule 3 (formals -> empty .)


state 4

    (4) formal -> object_identifier . colon type_identifier

    colon           shift and go to state 6


state 5

    (2) formals -> formals comma . formal
    (4) formal -> . object_identifier colon type_identifier

    object_identifier shift and go to state 4

    formal                         shift and go to state 7

state 6

    (4) formal -> object_identifier colon . type_identifier

    type_identifier shift and go to state 8


state 7

    (2) formals -> formals comma formal .

    comma           reduce using rule 2 (formals -> formals comma formal .)
    $end            reduce using rule 2 (formals -> formals comma formal .)


state 8

    (4) formal -> object_identifier colon type_identifier .

    comma           reduce using rule 4 (formal -> object_identifier colon type_identifier .)
    $end            reduce using rule 4 (formal -> object_identifier colon type_identifier .)

